use std::io::{self, Write};
use super::runtime::RUNTIME;

#[derive(Debug)]
pub struct Scope {
    pub functions: Vec<Function>,
    pub children: Vec<Node>,
}

impl Scope {
    pub fn new() -> Self {
        Scope {
            functions: Vec::new(),
            children: Vec::new(),
        }
    }

    pub fn register(&mut self, fun: Function) {
        self.functions.push(fun);
    }

    fn emit(&self, buf: &mut Write) -> io::Result<()> {
        // Emit runtime preamble.
                writeln!(buf, "{}", RUNTIME)?;

                // Emit function declarations.
                for fun in &self.functions {
                    writeln!(buf, "{};", fun.decl)?;
                }

                writeln!(buf, "")?;

                // Emit function definitions.
                for fun in &self.functions {
                    fun.emit(buf)?
                }

                // Emit main function.
                write!(buf, r#"void Init_stache() {{
                                   VALUE Stache = rb_define_module("Stache");
                                   VALUE Templates = rb_define_class_under(Stache, "Templates", rb_cObject);
                              "#)?;

                for fun in &program.functions {
                    if let Some(ref export) = fun.export {
                        writeln!(buf,
                                 "rb_define_method(Templates, \"{}\", {}, 1);",
                                 export,
                                 fun.name)?;
                    }
                }

                writeln!(buf, "}}")





        // Emit function declarations.
        for fun in &self.functions {
            writeln!(buf, "{};", fun.decl)?;
        }

        writeln!(buf, "")?;

        // Emit function definitions.
        for fun in &self.functions {
            fun.emit(buf)?
        }

        // Emit compiled nodes.
        for node in &self.children {
            println!("--- emit scope child {:?}", node);
            node.emit(buf)?;
        }

        Ok(())
    }
}

#[derive(Debug)]
pub struct Function {
    pub name: String,
    pub decl: String,
    pub children: Vec<String>,
    pub export: Option<String>,
}

impl Function {
    fn emit(&self, buf: &mut Write) -> io::Result<()> {
        writeln!(buf, "{} {{", self.decl)?;
        for node in &self.children {
            // node.emit(buf)?;
            write!(buf, "{}", node)?;
        }
        writeln!(buf, "}}\n")
    }
}

#[derive(Debug)]
pub enum Node {
    Executable(Scope),
    Source(String),
}

impl Node {
    pub fn emit(&self, buf: &mut Write) -> io::Result<()> {
        match *self {
            Node::Executable(ref program) => {
                            }
            Node::Source(ref text) => writeln!(buf, "{}", text),
        }
    }
}
